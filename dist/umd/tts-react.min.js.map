{"version":3,"file":"tts-react.min.js","sources":["../../src/utils.ts","../../src/controller.ts","../../src/highlighter.tsx","../../src/hook.tsx","../../src/icons.ts","../../src/control.tsx","../../src/component.tsx","../../src/languageTags.ts"],"sourcesContent":["import type { ReactNode } from 'react'\n\nconst punctuationRgx = /[^\\P{P}'/-]+/gu\nconst isStringOrNumber = (value: ReactNode): boolean => {\n  return typeof value === 'string' || typeof value === 'number'\n}\nconst stripPunctuation = (text: string): string => {\n  return text.replace(punctuationRgx, '')\n}\nconst isPunctuation = (text: string): boolean => {\n  const trimmed = text.trim()\n\n  return punctuationRgx.test(trimmed) && trimmed.length === 1\n}\n\nexport { isStringOrNumber, stripPunctuation, isPunctuation, punctuationRgx }\n","import { isPunctuation } from './utils'\n\nenum Events {\n  BOUNDARY = 'boundary',\n  END = 'end',\n  ERROR = 'error',\n  PAUSED = 'paused',\n  PITCH = 'pitch',\n  PLAYING = 'playing',\n  RATE = 'rate',\n  READY = 'ready',\n  VOLUME = 'volume'\n}\ninterface PollySpeechMark {\n  end: number\n  start: number\n  time: number\n  type: string\n  value: string\n}\ninterface TTSBoundaryUpdate {\n  word: string\n  startChar: number\n  endChar: number\n}\ninterface TTSAudioData {\n  audio: string\n  marks?: PollySpeechMark[]\n}\ninterface FetchAudioData {\n  (text: string): Promise<TTSAudioData>\n}\ninterface ControllerOptions {\n  lang?: string\n  voice?: SpeechSynthesisVoice\n  dispatchBoundaries?: boolean\n  fetchAudioData?: FetchAudioData\n}\ntype Target = HTMLAudioElement | SpeechSynthesisUtterance\ntype Synthesizer = HTMLAudioElement | SpeechSynthesis\ntype TTSEvent = SpeechSynthesisEvent | Event\n\nclass Controller extends EventTarget {\n  #target: Target\n  #synthesizer: Synthesizer\n  #dispatchBoundaries = true\n  #fetchAudioData: FetchAudioData = async () => ({ audio: '', marks: [] })\n  #marks: PollySpeechMark[] = []\n  #text = ''\n  #lang = ''\n  #aborter = new AbortController()\n  #initialized = false\n\n  constructor(options?: ControllerOptions) {\n    super()\n\n    this.#lang = options?.lang ?? this.#lang\n    this.#synthesizer = window.speechSynthesis\n    this.#target = new SpeechSynthesisUtterance(this.#text)\n    this.#dispatchBoundaries = options?.dispatchBoundaries ?? this.#dispatchBoundaries\n\n    if (options?.fetchAudioData) {\n      this.#target = this.#synthesizer = new Audio()\n      this.#fetchAudioData = options.fetchAudioData\n    } else {\n      this.#initWebSpeechVoice(options?.voice)\n\n      if (window.speechSynthesis) {\n        window.speechSynthesis.onvoiceschanged = () => {\n          this.#initWebSpeechVoice(options?.voice)\n        }\n      }\n    }\n  }\n\n  #initWebSpeechVoice(voice?: SpeechSynthesisVoice): void {\n    if (this.#target instanceof SpeechSynthesisUtterance) {\n      let voices = window.speechSynthesis.getVoices()\n\n      if (voice) {\n        this.#target.voice = voice\n      }\n\n      if (this.#lang) {\n        voices = voices.filter((voice) => voice.lang === this.#lang)\n        this.#target.voice = voices[0] ?? null\n\n        if (voice && voice.lang === this.#lang) {\n          this.#target.voice = voice\n        }\n      }\n    }\n  }\n\n  async #attachAudioSource(): Promise<void> {\n    if (this.#synthesizer instanceof HTMLAudioElement) {\n      let data: TTSAudioData | null = null\n\n      try {\n        data = await this.#fetchAudioData(this.#text)\n      } catch (err) {\n        if (err instanceof Error) {\n          this.#dispatchError(err.message)\n        }\n      } finally {\n        if (data?.audio) {\n          this.#synthesizer.src = data.audio\n          this.#marks = data.marks ?? this.#marks\n        }\n      }\n    }\n  }\n\n  #dispatchEnd(evt: TTSEvent): void {\n    this.dispatchEvent(new CustomEvent(Events.END, { detail: evt }))\n  }\n\n  #dispatchError(msg?: string): void {\n    this.dispatchEvent(new CustomEvent(Events.ERROR, { detail: msg }))\n  }\n\n  #dispatchReady(): void {\n    this.dispatchEvent(new Event(Events.READY))\n  }\n\n  #dispatchPlaying(evt: TTSEvent): void {\n    this.dispatchEvent(new CustomEvent(Events.PLAYING, { detail: evt }))\n  }\n\n  #dispatchPaused(evt: TTSEvent): void {\n    this.dispatchEvent(new CustomEvent(Events.PAUSED, { detail: evt }))\n  }\n\n  #dispatchBoundary(evt: TTSEvent, boundary: TTSBoundaryUpdate): void {\n    this.dispatchEvent(new CustomEvent(Events.BOUNDARY, { detail: { evt, boundary } }))\n  }\n\n  #dispatchVolume(volume: number): void {\n    this.dispatchEvent(new CustomEvent(Events.VOLUME, { detail: volume }))\n  }\n\n  #dispatchRate(rate: number): void {\n    this.dispatchEvent(new CustomEvent(Events.RATE, { detail: rate }))\n  }\n\n  #dispatchPitch(pitch: number): void {\n    this.dispatchEvent(new CustomEvent(Events.PITCH, { detail: pitch }))\n  }\n\n  async #playHtmlAudio(): Promise<void> {\n    const audio = this.#synthesizer as HTMLAudioElement\n\n    try {\n      await audio.play()\n    } catch (err) {\n      if (err instanceof Error) {\n        this.#dispatchError(err.message)\n      }\n    }\n  }\n\n  #getPollySpeechMarkForAudioTime(time: number): PollySpeechMark {\n    const length = this.#marks.length\n    let bestMatch = this.#marks[0]\n    let found = false\n    let i = 1\n\n    while (i < length && !found) {\n      if (this.#marks[i].time <= time) {\n        bestMatch = this.#marks[i]\n      } else {\n        found = true\n      }\n\n      i++\n    }\n\n    return bestMatch\n  }\n\n  /**\n   * Not all browsers return `evt.charLength` on SpeechSynthesisUtterance `boundary` events.\n   */\n  #getBoundaryWordCharLength(startIndex: number): number {\n    const match = this.#text.substring(startIndex).match(/.+?\\b/)\n\n    return match ? match[0].length : 0\n  }\n\n  #clamp(value: number, min = 0, max = 1): number {\n    return Math.max(min, Math.min(value, max))\n  }\n\n  /**\n   * Removes registered listeners and creates new abort controller.\n   */\n  #recycle(): AbortSignal {\n    this.#aborter.abort()\n    this.#aborter = new AbortController()\n\n    return this.#aborter.signal\n  }\n\n  #utteranceInit(): void {\n    if (this.#target instanceof SpeechSynthesisUtterance) {\n      const signal = this.#recycle()\n\n      this.#target.addEventListener('end', this.#dispatchEnd.bind(this), { signal })\n      this.#target.addEventListener('start', this.#dispatchPlaying.bind(this), { signal })\n      this.#target.addEventListener('resume', this.#dispatchPlaying.bind(this), {\n        signal\n      })\n      this.#target.addEventListener('pause', this.#dispatchPaused.bind(this), { signal })\n      this.#target.addEventListener(\n        'error',\n        (evt) => {\n          this.#dispatchError(evt.error)\n        },\n        { signal }\n      )\n\n      if (this.#lang) {\n        this.#target.lang = this.#lang\n      }\n\n      if (this.#dispatchBoundaries) {\n        this.#target.addEventListener(\n          'boundary',\n          (evt) => {\n            const { charIndex: startChar } = evt\n            const charLength =\n              evt.charLength ?? this.#getBoundaryWordCharLength(startChar)\n            const endChar = startChar + charLength\n            const word = this.#text.substring(startChar, endChar)\n\n            if (word && !isPunctuation(word)) {\n              this.#dispatchBoundary(evt, { word, startChar, endChar })\n            }\n          },\n          { signal }\n        )\n      }\n\n      this.#dispatchReady()\n    }\n  }\n\n  async #htmlAudioInit(): Promise<void> {\n    if (this.#target instanceof HTMLAudioElement) {\n      const target = this.#target\n\n      this.#target.addEventListener('canplay', this.#dispatchReady.bind(this), {\n        once: true\n      })\n      this.#target.addEventListener('playing', this.#dispatchPlaying.bind(this))\n      this.#target.addEventListener('pause', this.#dispatchPaused.bind(this))\n      this.#target.addEventListener('ended', this.#dispatchEnd.bind(this))\n      this.#target.addEventListener('error', () => {\n        const error = target.error\n\n        this.#dispatchError(error?.message)\n      })\n\n      if (this.#dispatchBoundaries) {\n        this.#target.addEventListener('timeupdate', (evt) => {\n          // Polly Speech Marks use milliseconds\n          const currentTime = target.currentTime * 1000\n          const mark = this.#getPollySpeechMarkForAudioTime(currentTime)\n\n          if (mark && !this.paused) {\n            this.#dispatchBoundary(evt, {\n              word: mark.value,\n              startChar: mark.start,\n              endChar: mark.end\n            })\n          }\n        })\n      }\n\n      await this.#attachAudioSource()\n    }\n  }\n\n  get synthesizer(): Synthesizer {\n    return this.#synthesizer\n  }\n\n  get target(): Target {\n    return this.#target\n  }\n\n  set text(value: string) {\n    this.#text = value\n\n    if (this.#target instanceof SpeechSynthesisUtterance) {\n      this.#target.text = value\n    }\n  }\n\n  get paused(): boolean {\n    return this.#synthesizer.paused\n  }\n\n  get rate(): number {\n    if (this.#synthesizer instanceof HTMLAudioElement) {\n      return this.#synthesizer.playbackRate\n    }\n\n    return (this.#target as SpeechSynthesisUtterance).rate\n  }\n\n  set rate(value: number) {\n    const clamped = this.#clamp(parseFloat(value.toPrecision(3)), 0.1, 10)\n\n    if (!Number.isNaN(clamped)) {\n      this.#dispatchRate(clamped)\n\n      if (this.#synthesizer instanceof HTMLAudioElement) {\n        this.#synthesizer.defaultPlaybackRate = clamped\n        this.#synthesizer.playbackRate = clamped\n      }\n\n      if (this.#target instanceof SpeechSynthesisUtterance) {\n        this.#target.rate = clamped\n      }\n    }\n  }\n\n  get pitch(): number {\n    if (this.#target instanceof SpeechSynthesisUtterance) {\n      return this.#target.pitch\n    }\n\n    // Not supported by HTMLAudioElement\n    return -1\n  }\n\n  set pitch(value: number) {\n    if (this.#target instanceof SpeechSynthesisUtterance) {\n      const clamped = this.#clamp(parseFloat(value.toPrecision(2)), 0, 2)\n\n      if (!Number.isNaN(clamped)) {\n        this.#dispatchPitch(clamped)\n        this.#target.pitch = clamped\n      }\n    }\n  }\n\n  /**\n   * Edge on Android was not working with toggling\n   * between volumes of zero and one. This sets a\n   * different lower and upper bound on the volume.\n   */\n  get volumeMin(): number {\n    return 0.01\n  }\n\n  get volumeMax(): number {\n    return 0.99\n  }\n\n  get volume(): number {\n    return this.#target.volume\n  }\n\n  set volume(value: number) {\n    const clamped = this.#clamp(\n      parseFloat(value.toPrecision(2)),\n      this.volumeMin,\n      this.volumeMax\n    )\n\n    if (!Number.isNaN(clamped)) {\n      this.#dispatchVolume(clamped)\n      this.#target.volume = clamped\n    }\n  }\n\n  get preservesPitch(): boolean {\n    if (this.#synthesizer instanceof HTMLAudioElement) {\n      return (this.#synthesizer as HTMLAudioElement & { preservesPitch: boolean })\n        .preservesPitch\n    }\n\n    return false\n  }\n\n  set preservesPitch(value: boolean) {\n    /**\n     * `preservesPitch` requires vendor-prefix on some browsers (Safari).\n     * @see https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1300\n     */\n    if (this.#synthesizer instanceof HTMLAudioElement) {\n      // eslint-disable-next-line @typescript-eslint/no-extra-semi\n      ;(\n        this.#synthesizer as HTMLAudioElement & { preservesPitch: boolean }\n      ).preservesPitch = value\n    }\n  }\n\n  get lang(): string {\n    return this.#lang\n  }\n\n  set lang(value: string) {\n    if (this.#target instanceof SpeechSynthesisUtterance) {\n      this.#lang = value\n      this.#target.lang = value\n      this.#target.voice = null\n      this.#initWebSpeechVoice()\n    }\n  }\n\n  /**\n   * Allows listeners for controller events to be registered\n   * before instances start firing events related to underlying API's,\n   * for instance in a useEffect block.\n   *\n   * Run it as async to allow for the fetchAudioData call to be awaited.\n   */\n  async init(): Promise<void> {\n    if (!this.#initialized) {\n      if (this.#target instanceof SpeechSynthesisUtterance) {\n        this.#utteranceInit()\n      }\n\n      if (this.#target instanceof HTMLAudioElement) {\n        await this.#htmlAudioInit()\n      }\n\n      this.#initialized = true\n    }\n  }\n\n  async play(): Promise<void> {\n    if (this.#synthesizer instanceof HTMLAudioElement) {\n      await this.#playHtmlAudio()\n    } else {\n      this.#synthesizer.speak(this.#target as SpeechSynthesisUtterance)\n    }\n  }\n\n  pause(): void {\n    this.#synthesizer.pause()\n  }\n\n  async resume(): Promise<void> {\n    if (this.#synthesizer instanceof HTMLAudioElement) {\n      await this.#playHtmlAudio()\n    } else {\n      this.#synthesizer.resume()\n    }\n  }\n\n  async replay(): Promise<void> {\n    if (this.#synthesizer instanceof HTMLAudioElement) {\n      this.#synthesizer.load()\n      await this.#playHtmlAudio()\n    } else {\n      // Take out of any paused state\n      this.#synthesizer.resume()\n      // Drop all utterances in the queue\n      this.#synthesizer.cancel()\n      // Start speaking from the beginning\n      this.#synthesizer.speak(this.#target as SpeechSynthesisUtterance)\n    }\n  }\n\n  cancel(): void {\n    if (this.#synthesizer instanceof HTMLAudioElement) {\n      this.#synthesizer.load()\n    } else {\n      this.#synthesizer.cancel()\n    }\n  }\n\n  mute(): void {\n    this.volume = 0\n\n    /**\n     * There is no way to effectively mute an ongoing utterance for SpeechSynthesis.\n     * If there is currently an utterance being spoken, replay to activate the muting instantly.\n     */\n    if (\n      !(this.#synthesizer instanceof HTMLAudioElement) &&\n      !this.paused &&\n      this.#synthesizer.speaking\n    ) {\n      this.replay()\n    }\n  }\n\n  unmute(volume?: number): void {\n    this.volume = volume ?? 1\n\n    /**\n     * Same as muting, for SpeechSynthesis have to replay to activate the volume change instantly.\n     */\n    if (\n      !(this.#synthesizer instanceof HTMLAudioElement) &&\n      !this.paused &&\n      this.#synthesizer.speaking\n    ) {\n      this.replay()\n    }\n  }\n}\n\nexport { Controller, Events }\nexport type {\n  TTSAudioData,\n  PollySpeechMark,\n  ControllerOptions,\n  TTSBoundaryUpdate,\n  TTSEvent\n}\n","import React, { useMemo } from 'react'\nimport type { CSSProperties } from 'react'\n\ninterface HighliterProps {\n  text: string\n  mark: string\n  color?: string\n  backgroundColor?: string\n}\n\nconst markStyles = ({\n  color,\n  backgroundColor\n}: Pick<HighliterProps, 'color' | 'backgroundColor'>): CSSProperties => ({\n  color,\n  backgroundColor\n})\nconst Highlighter = ({ text, mark, color, backgroundColor }: HighliterProps) => {\n  const markStyle = useMemo(\n    () => markStyles({ color, backgroundColor }),\n    [color, backgroundColor]\n  )\n  if (text && mark) {\n    const textStr = text.toString()\n    const escapedMark = mark.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&')\n    const regex = new RegExp(`(${escapedMark})`, 'gi')\n    const parts = textStr.split(regex)\n\n    if (parts.length > 1) {\n      return (\n        <span>\n          {parts.map((part, idx) => {\n            const key = `${part}-${idx}`\n\n            if (!part) {\n              // Happens when the entire text matches the mark\n              return null\n            }\n\n            if (regex.test(part)) {\n              return (\n                <mark key={key} style={markStyle} data-testid=\"tts-react-mark\">\n                  {part}\n                </mark>\n              )\n            }\n\n            return <span key={key}>{part}</span>\n          })}\n        </span>\n      )\n    }\n  }\n\n  return <>{text}</>\n}\n\nexport { Highlighter }\n","import React, {\n  useRef,\n  useMemo,\n  useReducer,\n  useCallback,\n  useEffect,\n  Children,\n  cloneElement,\n  isValidElement\n} from 'react'\nimport type { ReactNode } from 'react'\n\nimport { Controller, Events } from './controller'\nimport type { ControllerOptions, TTSBoundaryUpdate, TTSEvent } from './controller'\nimport { isStringOrNumber, stripPunctuation } from './utils'\nimport { Highlighter } from './highlighter'\n\n/**\n * Event handler for a TTS event:\n * - `onStart`\n * - `onPause`\n * - `onEnd`\n *\n * If not using `fetchAudioData` then the event will be `SpeechSynthesisEvent`.\n * Otherwise, the event will be the generic `Event` type used by `HTMLAudioElement`.\n */\ntype TTSEventHandler = (evt: SpeechSynthesisEvent | Event) => void\n/**\n * Event handler for a TTS error event.\n * `tts-react` wraps both `SpeechSynthesis` and `HTMLAudioElement` API's\n * which return the error information in diferrent ways. `tts-react` will\n * return the error message from to the handler if one is found.\n */\ntype TTSErrorHandler = (msg: string) => void\n/**\n * Event handler if an attribute of speaking has changed:\n * - volume\n * - rate\n * - pitch\n */\ntype TTSAudioChangeHandler = (newValue: number) => void\n/**\n * Event handler for TTS boundary events.\n *\n * If yousing `fetchAudioData` these events correspond to `timeupdate` events\n * for `HTMLAudioElement` where a `PollySpeechMark` could be found for the event's `currentTime`.\n *\n * Otherwise, these correspond to `boundary` events for `SpeechSynthesisUtterance`.\n */\ntype TTSBoundaryHandler = (\n  boundary: TTSBoundaryUpdate,\n  evt: SpeechSynthesisEvent | Event\n) => void\n\ninterface TTSOnEvent {\n  (evt: CustomEvent<TTSEvent>): void\n}\ninterface TTSOnBoundary {\n  (\n    evt: CustomEvent<{ boundary: TTSBoundaryUpdate; evt: SpeechSynthesisEvent | Event }>\n  ): void\n}\ninterface TTSOnError {\n  (evt: CustomEvent<string>): void\n}\ninterface TTSOnAudioChange {\n  (evt: CustomEvent<number>): void\n}\ninterface MarkStyles {\n  /** Text color of the currently marked word. */\n  markColor?: string\n  /** Background color of the currently marked word. */\n  markBackgroundColor?: string\n}\ninterface TTSHookProps extends MarkStyles {\n  /** The spoken text is extracted from here. */\n  children: ReactNode\n  /** The `SpeechSynthesisUtterance.lang` to use. */\n  lang?: ControllerOptions['lang']\n  /** The `SpeechSynthesisUtterance.voice` to use. */\n  voice?: ControllerOptions['voice']\n  /** The initial rate of the speaking audio. */\n  rate?: number\n  /** The initial volume of the speaking audio. */\n  volume?: number\n  /** Whether the text should be spoken automatically, i.e. on render. */\n  autoPlay?: boolean\n  /** Whether the spoken word should be wrapped in a `<mark>` element. */\n  markTextAsSpoken?: boolean\n  /** Callback when the volume is changed.  */\n  onVolumeChange?: TTSAudioChangeHandler\n  /** Callback when the rate is changed.  */\n  onRateChange?: TTSAudioChangeHandler\n  /** Callback when the pitch is changed.  */\n  onPitchChange?: TTSAudioChangeHandler\n  /** Callback when there is an error of any kind. */\n  onError?: TTSErrorHandler\n  /** Callback when speaking/audio starts playing. */\n  onStart?: TTSEventHandler\n  /** Callback when the speaking/audio is paused. */\n  onPause?: TTSEventHandler\n  /** Callback when a word boundary/mark has been reached. */\n  onBoundary?: TTSBoundaryHandler\n  /** Calback when the current utterance/audio has ended. */\n  onEnd?: TTSEventHandler\n  /** Function to fetch audio and speech marks for the spoken text. */\n  fetchAudioData?: ControllerOptions['fetchAudioData']\n}\ninterface TTSHookState {\n  voices: SpeechSynthesisVoice[]\n  boundary: TTSBoundaryUpdate\n  isPlaying: boolean\n  isPaused: boolean\n  isMuted: boolean\n  isError: boolean\n  isReady: boolean\n}\ninterface Action {\n  type:\n    | 'ready'\n    | 'pause'\n    | 'play'\n    | 'boundary'\n    | 'reset'\n    | 'end'\n    | 'error'\n    | 'muted'\n    | 'unmuted'\n    | 'stop'\n    | 'voices'\n  payload?: TTSBoundaryUpdate | SpeechSynthesisVoice[]\n}\ninterface ToggleMuteCallback {\n  (wasMuted: boolean): void\n}\ninterface TTSHookResponse {\n  set: {\n    lang: (value: string) => void\n    rate: (value: number) => void\n    pitch: (value: number) => void\n    volume: (value: number) => void\n    preservesPitch: (value: boolean) => void\n  }\n  get: {\n    lang: () => string\n    rate: () => number\n    pitch: () => number\n    volume: () => number\n    preservesPitch: () => boolean\n  }\n  /** State of the current speaking/audio. */\n  state: TTSHookState\n  /** The text extracted from the children elements and used to synthesize speech. */\n  spokenText: string\n  play: () => void\n  stop: () => void\n  pause: () => void\n  replay: () => void\n  /** Toggles between muted/unmuted, i.e. volume is zero or non-zero. */\n  toggleMute: (callback?: (wasMuted: boolean) => void) => void\n  /** Toggles between play/stop. */\n  playOrStop: () => void\n  /** Toggles between play/pause. */\n  playOrPause: () => void\n  /** The original children with a possible <mark> included if using `markTextAsSpoken`. */\n  ttsChildren: ReactNode\n}\ninterface TextBuffer {\n  text: string\n}\ninterface ParseChildrenProps extends MarkStyles {\n  children: ReactNode\n  buffer: TextBuffer\n  boundary: TTSBoundaryUpdate\n  markTextAsSpoken: boolean\n}\n\nconst parseChildrenRecursively = ({\n  children,\n  buffer,\n  boundary,\n  markColor,\n  markBackgroundColor,\n  markTextAsSpoken\n}: ParseChildrenProps): ReactNode => {\n  return Children.map(children, (child) => {\n    let currentChild = child\n\n    if (isValidElement(child)) {\n      currentChild = cloneElement(child, {\n        ...child.props,\n        children: parseChildrenRecursively({\n          buffer,\n          boundary,\n          markColor,\n          markBackgroundColor,\n          markTextAsSpoken,\n          children: child.props.children\n        })\n      })\n    }\n\n    if (isStringOrNumber(child)) {\n      const text = (child as string | number).toString()\n      const { word, startChar, endChar } = boundary\n      const bufferTextLength = buffer.text.length\n\n      buffer.text += `${text} `\n\n      if (markTextAsSpoken && word) {\n        const start = startChar - bufferTextLength\n        const end = endChar - bufferTextLength\n        const prev = text.substring(0, start)\n        const found = text.substring(start, end)\n        const after = text.substring(end, text.length)\n\n        if (found) {\n          return (\n            <>\n              {prev}\n              <Highlighter\n                text={found}\n                mark={stripPunctuation(found)}\n                color={markColor}\n                backgroundColor={markBackgroundColor}\n              />\n              {after}\n            </>\n          )\n        }\n      }\n    }\n\n    return currentChild\n  })\n}\nconst defaultBoundary = { word: '', startChar: 0, endChar: 0 }\nconst reducer = (state: TTSHookState, action: Action): TTSHookState => {\n  switch (action.type) {\n    case 'pause':\n      return { ...state, isPlaying: false, isPaused: true, isError: false }\n    case 'play':\n    case 'reset':\n      return {\n        ...state,\n        isPlaying: true,\n        isPaused: false,\n        isError: false,\n        boundary: defaultBoundary\n      }\n    case 'end':\n      return {\n        ...state,\n        isPlaying: false,\n        isPaused: false,\n        isError: false,\n        boundary: defaultBoundary\n      }\n    case 'error':\n      return {\n        ...state,\n        isPlaying: false,\n        isPaused: false,\n        isError: true,\n        boundary: defaultBoundary\n      }\n    case 'ready':\n      return { ...state, isReady: true }\n    case 'boundary':\n      return {\n        ...state,\n        boundary: { ...state.boundary, ...(action.payload as TTSBoundaryUpdate) }\n      }\n    case 'voices':\n      return { ...state, voices: action.payload as SpeechSynthesisVoice[] }\n    case 'stop':\n      return { ...state, isPlaying: false, isPaused: false, isError: false }\n    case 'muted':\n      return { ...state, isMuted: true }\n    case 'unmuted':\n      return { ...state, isMuted: false }\n  }\n}\nconst useTts = ({\n  lang,\n  rate,\n  volume,\n  voice,\n  children,\n  markColor,\n  markBackgroundColor,\n  onStart,\n  onPause,\n  onBoundary,\n  onEnd,\n  onError,\n  onVolumeChange,\n  onPitchChange,\n  onRateChange,\n  fetchAudioData,\n  autoPlay = false,\n  markTextAsSpoken = false\n}: TTSHookProps): TTSHookResponse => {\n  const spokenTextRef = useRef<string>()\n  const [state, dispatch] = useReducer(reducer, {\n    voices: window.speechSynthesis?.getVoices() ?? [],\n    boundary: defaultBoundary,\n    isPlaying: false,\n    isPaused: false,\n    isMuted: false,\n    isError: false,\n    isReady: typeof fetchAudioData === 'undefined'\n  })\n  const [ttsChildren, spokenText] = useMemo(() => {\n    if (typeof spokenTextRef.current === 'undefined' || markTextAsSpoken) {\n      const buffer: TextBuffer = { text: '' }\n      const parsed = parseChildrenRecursively({\n        children,\n        buffer,\n        markColor,\n        markBackgroundColor,\n        markTextAsSpoken,\n        boundary: state.boundary\n      })\n\n      spokenTextRef.current = buffer.text.trim()\n\n      return [parsed, spokenTextRef.current]\n    }\n\n    return [children, spokenTextRef.current]\n  }, [children, state.boundary, markColor, markBackgroundColor, markTextAsSpoken])\n  const controller = useMemo(\n    () =>\n      new Controller({\n        lang,\n        voice,\n        fetchAudioData\n      }),\n    [lang, voice, fetchAudioData]\n  )\n  const play = useCallback(async () => {\n    if (state.isPaused) {\n      controller.resume()\n    } else {\n      // Replay gives a more consistent/expected experience\n      controller.replay()\n    }\n\n    dispatch({ type: 'play' })\n  }, [controller, state.isPaused])\n  const pause = useCallback(() => {\n    controller.pause()\n    dispatch({ type: 'pause' })\n  }, [controller])\n  const replay = useCallback(() => {\n    controller.replay()\n    dispatch({ type: 'reset' })\n  }, [controller])\n  const stop = useCallback(() => {\n    controller.cancel()\n\n    dispatch({ type: 'stop' })\n  }, [controller])\n  const toggleMuteHandler = useCallback(\n    (callback?: ToggleMuteCallback) => {\n      const wasMuted = parseFloat(controller.volume.toFixed(2)) === controller.volumeMin\n\n      if (wasMuted) {\n        controller.unmute()\n        dispatch({ type: 'unmuted' })\n      } else {\n        controller.mute()\n        dispatch({ type: 'muted' })\n      }\n\n      if (typeof callback === 'function') {\n        callback(wasMuted)\n      }\n    },\n    [controller]\n  )\n  const playOrPause = useMemo(\n    () => (state.isPlaying ? pause : play),\n    [state.isPlaying, pause, play]\n  )\n  const playOrStop = useMemo(\n    () => (state.isPlaying ? stop : play),\n    [state.isPlaying, stop, play]\n  )\n  const [get, set] = useMemo(\n    () => [\n      {\n        lang() {\n          return controller.lang\n        },\n        rate() {\n          return controller.rate\n        },\n        pitch() {\n          return controller.pitch\n        },\n        volume() {\n          return controller.volume\n        },\n        preservesPitch() {\n          return controller.preservesPitch\n        }\n      },\n      {\n        lang(value: string) {\n          controller.lang = value\n        },\n        rate(value: number) {\n          controller.rate = value\n        },\n        pitch(value: number) {\n          controller.pitch = value\n        },\n        volume(value: number) {\n          controller.volume = value\n        },\n        preservesPitch(value: boolean) {\n          controller.preservesPitch = value\n        }\n      }\n    ],\n    [controller]\n  )\n  // Controller event listeners\n  const onStartHandler: TTSOnEvent = useCallback(\n    (evt) => {\n      dispatch({ type: 'play' })\n\n      if (typeof onStart === 'function') {\n        onStart(evt.detail)\n      }\n    },\n    [onStart]\n  )\n  const onPauseHandler: TTSOnEvent = useCallback(\n    (evt) => {\n      if (typeof onPause === 'function') {\n        onPause(evt.detail)\n      }\n    },\n    [onPause]\n  )\n  const onEndHandler: TTSOnEvent = useCallback(\n    (evt) => {\n      dispatch({ type: 'end' })\n\n      if (typeof onEnd === 'function') {\n        onEnd(evt.detail)\n      }\n    },\n    [onEnd]\n  )\n  const onReady = useCallback(() => {\n    dispatch({ type: 'ready' })\n  }, [])\n  const onErrorHandler: TTSOnError = useCallback(\n    (evt) => {\n      dispatch({ type: 'error' })\n\n      if (typeof onError === 'function') {\n        onError(evt.detail)\n      }\n    },\n    [onError]\n  )\n  const onBoundaryHandler: TTSOnBoundary = useCallback(\n    (evt) => {\n      dispatch({ type: 'boundary', payload: evt.detail.boundary })\n\n      if (typeof onBoundary === 'function') {\n        onBoundary(evt.detail.boundary, evt.detail.evt)\n      }\n    },\n    [onBoundary]\n  )\n  const onVolume: TTSOnAudioChange = useCallback(\n    (evt) => {\n      const volume = evt.detail\n      const min = controller.volumeMin\n\n      if (volume === min && controller.volume !== min) {\n        dispatch({ type: 'muted' })\n      }\n\n      if (volume !== min && controller.volume === min) {\n        dispatch({ type: 'unmuted' })\n      }\n\n      if (typeof onVolumeChange === 'function') {\n        onVolumeChange(volume)\n      }\n    },\n    [onVolumeChange, controller]\n  )\n  const onPitch: TTSOnAudioChange = useCallback(\n    (evt) => {\n      if (typeof onPitchChange === 'function') {\n        onPitchChange(evt.detail)\n      }\n    },\n    [onPitchChange]\n  )\n  const onRate: TTSOnAudioChange = useCallback(\n    (evt) => {\n      if (typeof onRateChange === 'function') {\n        onRateChange(evt.detail)\n      }\n    },\n    [onRateChange]\n  )\n\n  useEffect(() => {\n    controller.text = spokenText\n  }, [spokenText, controller])\n\n  useEffect(() => {\n    if (rate && Number.isFinite(rate)) {\n      controller.rate = rate\n    }\n\n    if (volume && Number.isFinite(volume)) {\n      controller.volume = volume\n    }\n  }, [controller, rate, volume])\n\n  useEffect(() => {\n    const onBeforeUnload = () => {\n      controller.cancel()\n    }\n    const initializeListeners = async () => {\n      controller.addEventListener(Events.PLAYING, onStartHandler as EventListener)\n      controller.addEventListener(Events.PAUSED, onPauseHandler as EventListener)\n      controller.addEventListener(Events.END, onEndHandler as EventListener)\n      controller.addEventListener(Events.ERROR, onErrorHandler as EventListener)\n      controller.addEventListener(Events.READY, onReady)\n      controller.addEventListener(Events.BOUNDARY, onBoundaryHandler as EventListener)\n      controller.addEventListener(Events.VOLUME, onVolume as EventListener)\n      controller.addEventListener(Events.PITCH, onPitch as EventListener)\n      controller.addEventListener(Events.RATE, onRate as EventListener)\n      window.addEventListener('beforeunload', onBeforeUnload)\n\n      await controller.init()\n    }\n\n    initializeListeners()\n\n    return () => {\n      window.removeEventListener('beforeunload', onBeforeUnload)\n      controller.removeEventListener(Events.PLAYING, onStartHandler as EventListener)\n      controller.removeEventListener(Events.PAUSED, onPauseHandler as EventListener)\n      controller.removeEventListener(Events.END, onEndHandler as EventListener)\n      controller.removeEventListener(Events.ERROR, onErrorHandler as EventListener)\n      controller.removeEventListener(Events.READY, onReady)\n      controller.removeEventListener(Events.BOUNDARY, onBoundaryHandler as EventListener)\n      controller.removeEventListener(Events.VOLUME, onVolume as EventListener)\n      controller.removeEventListener(Events.PITCH, onPitch as EventListener)\n      controller.removeEventListener(Events.RATE, onRate as EventListener)\n    }\n  }, [\n    onStartHandler,\n    onBoundaryHandler,\n    onPauseHandler,\n    onEndHandler,\n    onReady,\n    onErrorHandler,\n    onBoundary,\n    onVolume,\n    onPitch,\n    onRate,\n    controller\n  ])\n\n  useEffect(() => {\n    if (autoPlay && state.isReady) {\n      controller.replay()\n      dispatch({ type: 'play' })\n    }\n  }, [autoPlay, controller, state.isReady, spokenText])\n\n  useEffect(() => {\n    const onVoicesChanged = () => {\n      dispatch({ type: 'voices', payload: window.speechSynthesis.getVoices() })\n    }\n\n    if (typeof window.speechSynthesis?.addEventListener === 'function') {\n      window.speechSynthesis.addEventListener('voiceschanged', onVoicesChanged)\n    }\n\n    return () => {\n      if (typeof window.speechSynthesis?.removeEventListener === 'function') {\n        window.speechSynthesis.removeEventListener('voiceschanged', onVoicesChanged)\n      }\n    }\n  }, [])\n\n  return {\n    get,\n    set,\n    state,\n    spokenText,\n    ttsChildren,\n    play,\n    stop,\n    pause,\n    replay,\n    playOrStop,\n    playOrPause,\n    toggleMute: toggleMuteHandler\n  }\n}\n\nexport { useTts }\nexport type {\n  TTSHookProps,\n  TTSHookResponse,\n  TTSHookState,\n  TTSEventHandler,\n  TTSErrorHandler,\n  TTSBoundaryHandler,\n  TTSAudioChangeHandler\n}\n","enum Sizes {\n  SMALL = 'small',\n  MEDIUM = 'medium',\n  LARGE = 'large'\n}\n\ninterface SvgProps {\n  size?: `${Sizes}`\n}\n\nconst iconSizes = {\n  small: 16,\n  medium: 24,\n  large: 32\n}\nconst icons = {\n  play({ size = Sizes.MEDIUM }: SvgProps) {\n    return `\n      <svg\n        xmlns=\"http://www.w3.org/2000/svg\"\n        height=\"${iconSizes[size]}px\"\n        viewBox=\"0 0 24 24\"\n        width=\"${iconSizes[size]}px\"\n        fill=\"#000000\">\n        <style>\n          svg {\n            cursor: pointer;\n          }\n        </style>\n        <path d=\"M0 0h24v24H0z\" fill=\"none\" />\n        <path d=\"M8 5v14l11-7z\" />\n      </svg>\n    `\n  },\n  pause({ size = Sizes.MEDIUM }: SvgProps) {\n    return `\n      <svg\n        xmlns=\"http://www.w3.org/2000/svg\"\n        height=\"${iconSizes[size]}px\"\n        viewBox=\"0 0 24 24\"\n        width=\"${iconSizes[size]}px\"\n        fill=\"#000000\">\n        <style>\n          svg {\n            cursor: pointer;\n          }\n        </style>\n        <path d=\"M0 0h24v24H0z\" fill=\"none\" />\n        <path d=\"M6 19h4V5H6v14zm8-14v14h4V5h-4z\" />\n      </svg>\n    `\n  },\n  stop({ size = Sizes.MEDIUM }: SvgProps) {\n    return `\n      <svg\n        xmlns=\"http://www.w3.org/2000/svg\"\n        height=\"${iconSizes[size]}px\"\n        viewBox=\"0 0 24 24\"\n        width=\"${iconSizes[size]}px\"\n        fill=\"#000000\">\n        <style>\n          svg {\n            cursor: pointer;\n          }\n        </style>\n        <path d=\"M0 0h24v24H0z\" fill=\"none\" />\n        <path d=\"M6 6h12v12H6z\" />\n      </svg>\n    `\n  },\n  replay({ size = Sizes.MEDIUM }: SvgProps) {\n    return `\n      <svg\n        xmlns=\"http://www.w3.org/2000/svg\"\n        height=\"${iconSizes[size]}px\"\n        viewBox=\"0 0 24 24\"\n        width=\"${iconSizes[size]}px\"\n        fill=\"#000000\">\n        <style>\n          svg {\n            cursor: pointer;\n          }\n        </style>\n        <path d=\"M0 0h24v24H0z\" fill=\"none\" />\n        <path d=\"M12 5V1L7 6l5 5V7c3.31 0 6 2.69 6 6s-2.69 6-6 6-6-2.69-6-6H4c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8z\" />\n      </svg>\n    `\n  },\n  volumeDown({ size = Sizes.MEDIUM }: SvgProps) {\n    return `\n      <svg\n        xmlns=\"http://www.w3.org/2000/svg\"\n        height=\"${iconSizes[size]}px\"\n        viewBox=\"0 0 24 24\"\n        width=\"${iconSizes[size]}px\"\n        fill=\"#000000\">\n        <style>\n          svg {\n            cursor: pointer;\n          }\n        </style>\n        <path d=\"M0 0h24v24H0z\" fill=\"none\" />\n        <path d=\"M18.5 12c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM5 9v6h4l5 5V4L9 9H5z\" />\n      </svg>\n    `\n  },\n  volumeOff({ size = Sizes.MEDIUM }: SvgProps) {\n    return `\n      <svg\n        xmlns=\"http://www.w3.org/2000/svg\"\n        height=\"${iconSizes[size]}px\"\n        viewBox=\"0 0 24 24\"\n        width=\"${iconSizes[size]}px\"\n        fill=\"#000000\">\n        <style>\n          svg {\n            cursor: pointer;\n          }\n        </style>\n        <path d=\"M0 0h24v24H0z\" fill=\"none\" />\n        <path d=\"M16.5 12c0-1.77-1.02-3.29-2.5-4.03v2.21l2.45 2.45c.03-.2.05-.41.05-.63zm2.5 0c0 .94-.2 1.82-.54 2.64l1.51 1.51C20.63 14.91 21 13.5 21 12c0-4.28-2.99-7.86-7-8.77v2.06c2.89.86 5 3.54 5 6.71zM4.27 3L3 4.27 7.73 9H3v6h4l5 5v-6.73l4.25 4.25c-.67.52-1.42.93-2.25 1.18v2.06c1.38-.31 2.63-.95 3.69-1.81L19.73 21 21 19.73l-9-9L4.27 3zM12 4L9.91 6.09 12 8.18V4z\" />\n      </svg>\n    `\n  },\n  volumeUp({ size = Sizes.MEDIUM }: SvgProps) {\n    return `\n      <svg\n        xmlns=\"http://www.w3.org/2000/svg\"\n        height=\"${iconSizes[size]}px\"\n        viewBox=\"0 0 24 24\"\n        width=\"${iconSizes[size]}px\"\n        fill=\"#000000\">\n        <style>\n          svg {\n            cursor: pointer;\n          }\n        </style>\n        <path d=\"M0 0h24v24H0z\" fill=\"none\" />\n        <path d=\"M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z\" />\n      </svg>\n    `\n  }\n}\n\nexport { Sizes, iconSizes, icons }\nexport type { SvgProps }\n","import React, { useMemo, useEffect } from 'react'\nimport type { MouseEventHandler, CSSProperties } from 'react'\n\nimport { Sizes, icons, iconSizes } from './icons'\n\ninterface ControlProps {\n  title: string\n  size?: `${Sizes}`\n  align?: 'vertical' | 'horizontal'\n  type: 'play' | 'stop' | 'pause' | 'replay' | 'volumeDown' | 'volumeOff' | 'volumeUp'\n  onClick: MouseEventHandler<HTMLButtonElement>\n}\ntype ButtonStyleProps = Required<Pick<ControlProps, 'size' | 'align' | 'type'>>\n\nconst padding = {\n  [Sizes.SMALL]: 5,\n  [Sizes.MEDIUM]: 5,\n  [Sizes.LARGE]: 5\n}\nconst button = ({ size, align, type }: ButtonStyleProps): CSSProperties => {\n  const styles = {\n    margin: 0,\n    padding: `${padding[size]}px`,\n    border: 'none',\n    borderRadius: `${iconSizes[size]}px`,\n    color: 'black',\n    cursor: 'pointer',\n    display: 'flex',\n    alignItems: 'center',\n    justifyContent: 'center',\n    backgroundColor: 'transparent'\n  }\n\n  if (type === 'replay') {\n    // Include left/right padding + gutter\n    const value = `-${iconSizes[size] + 2 * padding[size] + 5}px`\n    const property = align === 'horizontal' ? 'right' : 'bottom'\n\n    return {\n      ...styles,\n      [property]: value,\n      position: 'absolute',\n      background: '#f2f1f1a6',\n      zIndex: 9999\n    }\n  }\n\n  return styles\n}\nconst Control = ({\n  title,\n  type,\n  onClick,\n  size = Sizes.MEDIUM,\n  align = 'horizontal',\n  ...rest\n}: ControlProps) => {\n  const styleDataId = 'tts-react-controls'\n  const svg = useMemo(() => {\n    return icons[type]({ size })\n  }, [type, size])\n  const btnStyle = useMemo(() => button({ size, align, type }), [size, align, type])\n\n  useEffect(() => {\n    // Keep pseudo styles in stylesheets where they are supported.\n    let style = document.querySelector(`style[data-id=\"${styleDataId}\"]`)\n\n    if (!style) {\n      style = document.createElement('style')\n      style.setAttribute('data-id', styleDataId)\n      style.innerHTML = `\n        button[data-tts-react-control]:hover {\n          background-color: #ebeaeaa6 !important;\n        }\n        button[data-id=\"tts-react-replay\"]:hover {\n          filter: brightness(0.98);\n        }\n      `\n      document.head.appendChild(style)\n    }\n\n    return () => {\n      // Cleanup reference to DOM element\n      style = null\n    }\n  }, [align, size, type])\n\n  return (\n    <button\n      title={title}\n      data-tts-react-control\n      data-id={`tts-react-${type}`}\n      onClick={onClick}\n      style={btnStyle}\n      dangerouslySetInnerHTML={{ __html: svg }}\n      {...rest}\n    />\n  )\n}\n\nexport { Control, padding }\nexport type { ControlProps }\n","// No umd build for react/jsx-runtime @see https://github.com/facebook/react/issues/20923\nimport React, { useMemo, useCallback } from 'react'\nimport type { CSSProperties } from 'react'\n\nimport { useTts } from './hook'\nimport type { TTSHookProps } from './hook'\nimport { iconSizes, Sizes } from './icons'\nimport type { SvgProps } from './icons'\nimport { Control, padding as ctrlPadding } from './control'\nimport type { ControlProps } from './control'\n\nenum Positions {\n  TL = 'topLeft',\n  TR = 'topRight',\n  BL = 'bottomLeft',\n  BR = 'bottomRight',\n  TC = 'topCenter',\n  RC = 'rightCenter',\n  BC = 'bottomCenter',\n  LC = 'leftCenter'\n}\ninterface TTSProps extends TTSHookProps {\n  /** How the controls are aligned within the `TextToSpeech` component. */\n  align?: 'vertical' | 'horizontal'\n  /** The relative size of the controls within the `TextToSpeech` component. */\n  size?: SvgProps['size']\n  /** The relative position of the controls within the `TextToSpeech` component. */\n  position?: `${Positions}`\n  /** Whether the `TextToSpeech` component should render the audio toggling control. */\n  allowMuting?: boolean\n  /** Callback when the `TextToSpeech` component's audio toggling control is clicked. */\n  onMuteToggled?: (wasMuted: boolean) => void\n  /** Whether the `TextToSpeech` component should render a stop control instead of pause. */\n  useStopOverPause?: boolean\n}\ntype StyleProps = Pick<TTSProps, 'align' | 'position' | 'size'>\n\nconst wrap = ({ position = Positions.LC }: StyleProps): CSSProperties => {\n  let gridTemplateAreas = `'cnt ctl'`\n  let gridTemplateColumns = '1fr auto'\n  let alignItems = 'start'\n\n  switch (position) {\n    case Positions.TL:\n      gridTemplateAreas = `'ctl cnt'`\n      gridTemplateColumns = 'auto 1fr'\n      break\n    case Positions.BL:\n      gridTemplateAreas = `'ctl cnt'`\n      alignItems = 'end'\n      gridTemplateColumns = 'auto 1fr'\n      break\n    case Positions.BR:\n      gridTemplateAreas = `'cnt ctl'`\n      alignItems = 'end'\n      break\n    case Positions.TC:\n      gridTemplateColumns = '1fr'\n      gridTemplateAreas = `'ctl'\\n'cnt'`\n      alignItems = 'center'\n      break\n    case Positions.RC:\n      alignItems = 'center'\n      break\n    case Positions.BC:\n      gridTemplateColumns = '1fr'\n      gridTemplateAreas = `'cnt'\\n'ctl'`\n      alignItems = 'center'\n      break\n    case Positions.LC:\n      gridTemplateAreas = `'ctl cnt'`\n      gridTemplateColumns = 'auto 1fr'\n      alignItems = 'center'\n  }\n\n  return {\n    alignItems,\n    gridTemplateAreas,\n    gridTemplateColumns,\n    display: 'grid',\n    gap: '15px'\n  }\n}\nconst controls = ({\n  align,\n  position = Positions.LC,\n  size = Sizes.MEDIUM\n}: StyleProps): CSSProperties => {\n  return {\n    position: 'relative',\n    display: 'inline-flex',\n    flexDirection: align === 'horizontal' ? 'row' : 'column',\n    gap: '5px',\n    gridArea: 'ctl',\n    padding: 0,\n    margin: position.includes('Center') ? 'auto' : 0,\n    backgroundColor: '#f2f1f1a6',\n    borderRadius: `${iconSizes[size] + ctrlPadding[size]}px`,\n    border: '1px solid transparent'\n  }\n}\nconst content = (): CSSProperties => {\n  return {\n    gridArea: 'cnt'\n  }\n}\n/**\n * `useTts` is a React hook for converting text to speech using\n * the `SpeechSynthesis` and `SpeechSynthesisUtterance` Browser API's.\n * Optionally, you can fallback to using the `HTMLAudioElement` API\n * when setting the `fetchAudioData` prop, for example to use Amazon Polly.\n *\n * The `TextToSpeech` component is an implementation of `useTts` that provides\n * controls for playing, pausing/stopping, and replaying the spoken text.\n * It also extends the props of `useTts` by supporting some of it's own:\n *\n * - `align`\n * - `allowMuting`\n * - `onMuteToggled`\n * - `position`\n * - `size`\n * - `useStopOverPause`\n */\nconst TextToSpeech = ({\n  size,\n  lang,\n  rate,\n  voice,\n  volume,\n  children,\n  position,\n  onStart,\n  onPause,\n  onBoundary,\n  onEnd,\n  onError,\n  onMuteToggled,\n  onVolumeChange,\n  onPitchChange,\n  onRateChange,\n  fetchAudioData,\n  markColor,\n  markBackgroundColor,\n  autoPlay = false,\n  allowMuting = true,\n  align = 'horizontal',\n  markTextAsSpoken = false,\n  useStopOverPause = false\n}: TTSProps) => {\n  const { state, replay, toggleMute, playOrPause, playOrStop, ttsChildren } = useTts({\n    lang,\n    rate,\n    voice,\n    volume,\n    children,\n    onStart,\n    onPause,\n    onBoundary,\n    onEnd,\n    onError,\n    onVolumeChange,\n    onPitchChange,\n    onRateChange,\n    fetchAudioData,\n    autoPlay,\n    markColor,\n    markBackgroundColor,\n    markTextAsSpoken\n  })\n  const wrapStyle = useMemo(() => wrap({ position }), [position])\n  const controlsStyle = useMemo(\n    () => controls({ align, position, size }),\n    [align, position, size]\n  )\n  const contentStyle = useMemo(() => content(), [])\n  const [type, title, onClick] = useMemo(() => {\n    if (state.isPlaying) {\n      if (useStopOverPause) {\n        return ['stop', 'Stop', playOrStop]\n      }\n\n      return ['pause', 'Pause', playOrPause]\n    }\n\n    return ['play', 'Play', playOrPause]\n  }, [state.isPlaying, useStopOverPause, playOrStop, playOrPause])\n  const handleOnMuteClicked = useCallback(() => {\n    toggleMute(onMuteToggled)\n  }, [toggleMute, onMuteToggled])\n\n  return (\n    <div style={wrapStyle} className=\"tts-react\" data-testid=\"tts-react\">\n      {state.isReady && (\n        <aside style={controlsStyle} data-testid=\"tts-react-controls\">\n          {allowMuting && (\n            <Control\n              size={size}\n              align={align}\n              title={state.isMuted ? 'Unmute' : 'Mute'}\n              aria-label={state.isMuted ? 'Unmute' : 'Mute'}\n              onClick={handleOnMuteClicked}\n              type={\n                state.isMuted ? 'volumeOff' : state.isPlaying ? 'volumeUp' : 'volumeDown'\n              }\n            />\n          )}\n          <Control\n            type={type as ControlProps['type']}\n            title={title}\n            aria-label={title}\n            onClick={onClick}\n            size={size}\n            align={align}\n          />\n          {state.isPaused && (\n            <Control\n              type=\"replay\"\n              size={size}\n              align={align}\n              title=\"Replay\"\n              aria-label=\"Replay\"\n              onClick={replay}\n            />\n          )}\n        </aside>\n      )}\n      <div style={contentStyle}>{ttsChildren}</div>\n    </div>\n  )\n}\n\nexport { Sizes } from './icons'\nexport { TextToSpeech, Positions }\nexport type { TTSProps }\n","/**\n * BCP 47 Language Tags that can be used for `SpeechSynthesisVoice.lang`.\n */\nexport enum LanguageTags {\n  ARABIC_SAUDI_ARABIA = 'ar-SA',\n  CZECH_CZECH_REPUBLIC = 'cs-CZ',\n  DANISH_DENMARK = 'da-DK',\n  GERMAN_GERMANY = 'de-DE',\n  MODERN_GREEK_GREECE = 'el-GR',\n  ENGLISH_AUSTRALIA = 'en-AU',\n  ENGLISH_UNITED_KINGDOM = 'en-GB',\n  ENGLISH_IRELAND = 'en-IE',\n  ENGLISH_UNITED_STATES = 'en-US',\n  ENGLISH_SOUTH_AFRICA = 'en-ZA',\n  SPANISH_SPAIN = 'es-ES',\n  SPANISH_MEXICO = 'es-MX',\n  FINNISH_FINLAND = 'fi-FI',\n  FRENCH_CANADA = 'fr-CA',\n  FRENCH_FRANCE = 'fr-FR',\n  HEBREW_ISRAEIL = 'he-IL',\n  HINDI_INDIA = 'hi-IN',\n  HUNGARIAN_HUNGARY = 'hu-HU',\n  INDONESIAN_INDONESIA = 'id-ID',\n  ITALIAN_ITALY = 'it-IT',\n  JAPANESE_JAPAN = 'ja-JP',\n  KOREAN_REPUBLIC_OF_KOREA = 'ko-KR',\n  DUTCH_BELGIUM = 'nl-BE',\n  DUTCH_NETHERLANDS = 'nl-NL',\n  NORWEGIAN_NORWAY = 'no-NO',\n  POLISH_POLAND = 'pl-PL',\n  PORTUGUESE_BRAZIL = 'pt-BR',\n  PORTUGUESE_PORTUGAL = 'pt-PT',\n  ROMANIAN_ROMANIA = 'ro-RO',\n  RUSSIAN_RUSSIAN_FEDERATION = 'ru-RU',\n  SLOVAK_SLOVAKIA = 'sk-SK',\n  SWEDISH_SWEDEN = 'sv-SE',\n  THAI_THAILAND = 'th-TH',\n  TURKISH_TURKEY = 'tr-TR',\n  CHINESE_CHINA = 'zh-CN',\n  CHINESE_HONG_KONG = 'zh-HK',\n  CHINESE_TAIWAN = 'zh-TW'\n}\n"],"names":["punctuationRgx","stripPunctuation","text","replace","_this7","this","_classPrivateFieldLooseBase","HTMLAudioElement","target","_target","addEventListener","bind","once","_dispatchPlaying","error","message","_dispatchBoundaries","evt","currentTime","mark","_getPollySpeechMarkForAudioTime","paused","word","value","startChar","start","endChar","end","Promise","resolve","_attachAudioSource","then","_temp10","_playHtmlAudio2","_this6","audio","_synthesizer","_temp9","_catch","play","err","_dispatchError","e","reject","_attachAudioSource2","_this5","_temp8","_temp7","data","_finallyRethrows","_data","src","_marks","marks","_wasThrown","_result","Events","Controller","EventTarget","constructor","options","super","Object","defineProperty","_htmlAudioInit","_htmlAudioInit2","_utteranceInit","_utteranceInit2","_recycle","_recycle2","_clamp","_clamp2","_getBoundaryWordCharLength","_getBoundaryWordCharLength2","_getPollySpeechMarkForAudioTime2","_playHtmlAudio","_dispatchPitch","_dispatchPitch2","_dispatchRate","_dispatchRate2","_dispatchVolume","_dispatchVolume2","_dispatchBoundary","_dispatchBoundary2","_dispatchPaused","_dispatchPaused2","_dispatchPlaying2","_dispatchReady","_dispatchReady2","_dispatchError2","_dispatchEnd","_dispatchEnd2","_initWebSpeechVoice","_initWebSpeechVoice2","writable","_fetchAudioData","_lang","_aborter","AbortController","lang","window","speechSynthesis","SpeechSynthesisUtterance","_text","dispatchBoundaries","fetchAudioData","Audio","voice","onvoiceschanged","synthesizer","rate","playbackRate","clamped","parseFloat","toPrecision","Number","isNaN","defaultPlaybackRate","pitch","volumeMin","volumeMax","volume","preservesPitch","init","_this","_initialized","_temp2","_this2","speak","_temp4","pause","resume","_temp5","_this3","replay","_this4","_temp6","load","cancel","mute","speaking","unmute","getVoices","voices","filter","dispatchEvent","CustomEvent","END","detail","msg","ERROR","Event","READY","PLAYING","PAUSED","boundary","BOUNDARY","VOLUME","RATE","PITCH","time","length","found","i","bestMatch","startIndex","match","substring","min","max","Math","abort","signal","charIndex","charLength","trimmed","trim","test","isPunctuation","Highlighter","_ref2","color","backgroundColor","markStyle","useMemo","_ref","markStyles","textStr","toString","regex","RegExp","escapedMark","parts","split","React","createElement","map","part","idx","key","style","Fragment","parseChildrenRecursively","children","buffer","markColor","markBackgroundColor","markTextAsSpoken","Children","child","currentChild","isValidElement","cloneElement","props","bufferTextLength","prev","after","defaultBoundary","reducer","state","action","type","isPlaying","isPaused","isError","isReady","payload","isMuted","useTts","_window$speechSynthes","onStart","onPause","onBoundary","onEnd","onError","onVolumeChange","onPitchChange","onRateChange","autoPlay","spokenTextRef","useRef","dispatch","useReducer","ttsChildren","spokenText","current","parsed","controller","useCallback","stop","toggleMuteHandler","callback","wasMuted","toFixed","playOrPause","playOrStop","get","set","onStartHandler","onPauseHandler","onEndHandler","onReady","onErrorHandler","onBoundaryHandler","onVolume","onPitch","onRate","useEffect","isFinite","onBeforeUnload","initializeListeners","removeEventListener","_window$speechSynthes2","onVoicesChanged","_window$speechSynthes3","toggleMute","Sizes","iconSizes","small","medium","large","icons","size","MEDIUM","_ref3","_ref4","volumeDown","_ref5","volumeOff","_ref6","volumeUp","_ref7","padding","SMALL","LARGE","Control","title","onClick","align","rest","styleDataId","svg","btnStyle","styles","margin","border","borderRadius","cursor","display","alignItems","justifyContent","property","position","background","zIndex","button","document","querySelector","setAttribute","innerHTML","head","appendChild","dangerouslySetInnerHTML","__html","Positions","LanguageTags","exports","onMuteToggled","allowMuting","useStopOverPause","wrapStyle","LC","gridTemplateColumns","TL","gridTemplateAreas","BL","BR","TC","RC","BC","gap","wrap","flexDirection","gridArea","includes","ctrlPadding","controls","contentStyle","handleOnMuteClicked","className","controlsStyle"],"mappings":"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"}